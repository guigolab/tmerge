=head1 NAME

tmerge

=head1 SYNOPSIS

Merge transcriptome read-to-genome alignments into non-redundant transcript models.

C<tmerge> compares transcript structures (or read-to-genome alignments) present in the input and attempts to reduce transcript redundancy, I<i.e.>, merge compatible input transcripts into non-redundant transcript models.

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_1.png" alt="tmerge sketch" /></p>

=end HTML

See DESCRIPTION below for more details.

B<Usage example>:

C<< tmerge --cpu <number of CPUs> --tmPrefix <custom transcript_id prefix string for output GTF> <input GTF file> > <output file> >>


=head2 INPUT

GTF file of read-to-genome alignments, sorted by chromosome and start position.

Only C<exon> records are considered.
Read alignments need to be uniquely identified with the C<transcript_id> GTF attribute. C<transcript_id> is the only mandatory GTF attribute in input records.

=head2 OPTIONS

=over

=item * C<cpu> (integer) = Number of CPUs to use

Default: 1

=item * C<tmPrefix> (string) = Prefix string for C<transcript_id> identifiers in the output

Default: '' (empty string)

By default, output C<transcript_id>s consist in arbitrary "C<TM_XXXXXXXXXXXX>" strings. If C<tmPrefix> is set, its value will prefix all C<transcript_id> strings in the GTF output.

=back

=head2 OUTPUT

C<tmerge> outputs non-redundant transcript models (B<TMs>) in GTF format. Each TM entry is uniquely identified by its C<transcript_id> attribute.

The C<gene_id> attribute has the same value as C<transcript_id> by convention; it is therefore meaningless.

An extra GTF attribute, C<contains>, consists of a comma-separated list of input C<transcript_id>s contained in the corresponding TM.


=head1 DESCRIPTION

C<tmerge> reduces redundancy in a set of transcriptome read-to-genome alignments. It does so by looking for reads with I<B<compatible>> aligned structures in the input, and merging those into I<B<Transcript Models>> (B<TMs>).

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_1.png" alt="tmerge sketch" /></p>

=end HTML

Pairwise B<compatibility> between aligned structures is evaluated using the following rules:

=over

=item * If both structures are B<spliced>, they are deemed compatible if:

=over

=item * 1. they show exonic overlap on the same genomic strand

and

=item * 2. either their intron chains are equal, or one is an exact subset of the other.

=back

Condition (2) means that C<tmerge>, contrary to other transcript mergers, will never artificially extend spliced transcripts:

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_non_merge.png" alt="tmerge non-merge case" /></p>

=end HTML

=item * If both structures are B<monoexonic>, they are considered compatible if they overlap by at least 1 nucleotide on the same genomic strand.

=item * If one structure is B<spliced> and the other B<monoexonic>, they are compatible if:

=over

=item * 1. they show exonic overlap on the same genomic strand

and

=item * 2. the latter does not overlap any intron of the former.


In other words, a monoexonic read can be included into a spliced transcript only if it doesn't alter its intron chain.

=back

=back


All pairs of compatible structures are then merged recursively into the longest possible TM.

B<WARNING>: Given the rules above, recursive merging of monoexonic structures into terminal exons of spliced models can lead to cases that one might consider undesirable, like the following:

=begin HTML

<p><img src="https://public-docs.crg.es/rguigo/CLS/img/tmerge_terminal_exons.png" alt="tmerge terminal exons" /></p>

=end HTML




=head1 DEPENDENCIES

=over

=item UUID::Generator::PurePerl

Install (bash): C<< $ cpanm UUID::Generator::PurePerl >>

=item Parallel::ForkManager

Install (bash): C<< $ cpanm Parallel::ForkManager >>

=back

(When using C<cpanm> you might have to use the C<--local-lib> option if you don't have admin rights, see documentation.


=head1 AUTHOR

Julien Lagarde, CRG, Barcelona, contact julienlag@gmail.com

