#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use UUID::Generator::PurePerl;
use Getopt::Long;
use Pod::Usage;
use Parallel::ForkManager;
#use Devel::Size qw(size total_size);





no warnings 'recursion';

my $message_text  = "Error\n";
my $exit_status   = 2;          ## The exit status to use
my $verbose_level = 99;          ## The verbose level to use
my $filehandle    = \*STDERR;   ## The filehandle to write to
my $sections = "NAME|SYNOPSIS|DESCRIPTION";


=head1 NAME

tmerge

=head1 SYNOPSIS

Merge transcriptome read-to-genome alignments into non-redundant transcript models.

C<tmerge> compares transcript structures (or read-to-genome alignments) present in the input and attempts to reduce transcript redundancy, I<i.e.>, merge compatible input transcripts into non-redundant transcript models. One notable limitation of the program is that it currently treats spliced and monoexonic reads separately (i.e. those are never merged together).

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_1.png" alt="tmerge sketch" /></p>

=end HTML

See DESCRIPTION below for more details.

B<Usage example>:

C<< tmerge --cpu <number of CPUs> --tmPrefix <custom transcript_id prefix string for output GTF> <input GTF file> > <output file> >>


=head2 INPUT

GTF file of read-to-genome alignments, sorted by chromosome and start position.

Only C<exon> records are considered.
Read alignments need to be uniquely identified with the C<transcript_id> GTF attribute. C<transcript_id> is the only mandatory GTF attribute in input records.

=head2 OPTIONS

=over

=item * C<cpu> (integer) = Number of CPUs to use

Default: 1

=item * C<tmPrefix> (string) = Prefix string for C<transcript_id> identifiers in the output

Default: '' (empty string)

By default, output C<transcript_id>s consist in arbitrary "C<TM_XXXXXXXXXXXX>" strings. If C<tmPrefix> is set, its value will prefix all C<transcript_id> strings in the GTF output.

=back

=head2 OUTPUT

C<tmerge> outputs non-redundant transcript models (B<TMs>) in GTF format. Each TM entry is uniquely identified by its C<transcript_id> attribute.

The C<gene_id> attribute has the same value as C<transcript_id> by convention; it is therefore meaningless.

An extra GTF attribute, C<contains>, consists of a comma-separated list of input C<transcript_id>s contained in the corresponding TM.


=head1 DESCRIPTION

C<tmerge> reduces redundancy in a set of transcriptome read-to-genome alignments. It does so by looking for reads with I<B<compatible>> aligned structures in the input, and merging those into I<B<Transcript Models>> (B<TMs>).

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_1.png" alt="tmerge sketch" /></p>

=end HTML

Pairwise B<compatibility> between aligned structures is evaluated using the following rules:

=over

=item * If both structures are B<spliced>, they are deemed compatible if:

=over

=item * 1. they show exonic overlap on the same genomic strand,

=item * 2. all their introns are compatible,

and

=item * 3. there is no overlap between an exon of one structure and an intron of the other.

=back

=item * If both structures are B<monoexonic>, they are considered compatible if they overlap by at least 1 nucleotide on the same genomic strand.

=item * If one structure is B<spliced> and the other B<monoexonic>, they are not merged (this may be modified in a future version)

=back


All pairs of compatible structures are then merged recursively into the longest possible TM.


=head1 DEPENDENCIES

=over

=item * UUID::Generator::PurePerl

Install (bash): C<< $ cpanm UUID::Generator::PurePerl >>

=item * Parallel::ForkManager

Install (bash): C<< $ cpanm Parallel::ForkManager >>

=back

(When using C<cpanm> you might need to use the C<--local-lib> option if you don't have admin rights, see documentation).


=head1 AUTHOR

Julien Lagarde, CRG, Barcelona, contact julienlag@gmail.com

=cut



my $tmPrefix='';
my $cpu=1;
GetOptions ('tmPrefix=s' => \$tmPrefix,
            'cpu=i' => \$cpu
            )
or pod2usage( { -message => "Error in command line arguments",
        		  -exitval => $exit_status  ,
            		-verbose => $verbose_level,
               -output  => $filehandle } );

unless (defined $ARGV[0]){
	pod2usage( { -message => "Error in command line arguments: no input provided.",
        		  -exitval => $exit_status  ,
            		-verbose => $verbose_level,
               -output  => $filehandle } );
}

my $tmpdir="/tmp/";
if(exists $ENV{'TMPDIR'}){
	$tmpdir=$ENV{'TMPDIR'};
}
print STDERR "Using TMP DIR: $tmpdir (to change that, edit the TMPDIR environment variable)\n";

my $process_manager = Parallel::ForkManager->new($cpu);

my $sortedGff;
if(defined($ARGV[0])){
	$sortedGff=$ARGV[0];
}
else{
	die "Need input GTF file name as argument.\n";
}

open GFF, "$sortedGff" or die $!;

my %transcript_to_transcript=();
my %transcript_exons=();
my %transcript_chr=();
my %transcript_strand=();
my $previous_start=-1;
my $previous_chr='Caravaggio';
my $previous_transcript='Delacroix';
my $superExonStart=-1;
my $superExonStop=-1;
my %transcript_id_index=();

print STDERR "Parsing GTF input...\n";
my $nr_exons=0;
my $transcript_count=0;
my %transcript_seen=();
my %transcript_index=();
my %transcript_rev_index=();
while (<GFF>){
	next if ($_=~/^#/);
	next unless ($_=~/\texon\t/);
	if ($_=~/^(\S+)\t(\S+)\t(\S+)\t(\d+)\t(\d+)\t\S+\t(\S+)\t\S+\t.*transcript_id "(\S+)?";/){
		if ($3 eq "exon"){
			$nr_exons++;
			my $GTFtranscript_id=$7;
			my $chr=$1;
			my $start=$4;
			my $stop=$5;
			my $str=$6;
			my $strand;
			if($str eq '+'){
				$strand=1;
			}
			elsif($str eq '-'){
				$strand=-1;
			}
			elsif($str eq '.'){
				$strand=0;
			}
			else{
				die "Unrecognized strand value '$str' at line $.\n";
			}
			unless(exists $transcript_seen{$GTFtranscript_id}){
				$transcript_count++;
				$transcript_seen{$GTFtranscript_id}=undef;
				$transcript_index{$transcript_count}=$GTFtranscript_id;
				$transcript_rev_index{$GTFtranscript_id}=$transcript_count;
			}

			my $transcript_id=$transcript_rev_index{$GTFtranscript_id};
			#Check for sorted input:
			die "ERROR: Unsorted GTF input (line $.). Must be sorted by chr, then start, then stop. Can't continue.\n" if ($chr eq $previous_chr && $start < $previous_start);
			$transcript_strand{$transcript_id}=$strand;
			$transcript_chr{$transcript_id}=$chr;
			my @exon=($chr, $start, $stop, $strand);
			push(@{$transcript_exons{$transcript_id}}, \@exon);
			$transcript_to_transcript{$transcript_id}{$transcript_id}=undef;
			my $overlapWithPrevious=overlap($superExonStart, $superExonStop, $start, $stop);
			if ($chr eq $previous_chr && $overlapWithPrevious == 1){
				$transcript_to_transcript{$transcript_id}{$previous_transcript}=undef;
				$transcript_to_transcript{$previous_transcript}{$transcript_id}=undef;
				if($stop > $superExonStop){
					$superExonStop = $stop;
				}
			}

			else{
				#re-initialize superExon
				$previous_chr=$chr;
				$superExonStart=$start;
				$superExonStop=$stop;
			}
			$previous_transcript=$transcript_id;
			$previous_start=$start;
		}
	}
	else{
		die "ERROR: line $.: malformed GTF record. Can't continue.\n";

	}

}
close GFF;
print STDERR "Done. Found $nr_exons exons and $transcript_count transcripts.\n";
%transcript_seen=();
%transcript_rev_index=();

print STDERR "Building contigs (sets of overlapping transcripts)...\n";

my $ug = UUID::Generator::PurePerl->new();
my $locusNumber = $ug->generate_v1();
my %transcript_id_to_locus_id=();
foreach my $tr1 (keys %transcript_to_transcript){
	buildContig($tr1, \%transcript_to_transcript, \%transcript_id_to_locus_id, $locusNumber);
	#generate UUID for contig (this is to write temp files):
	my $ug = UUID::Generator::PurePerl->new();
    $locusNumber = $ug->generate_v1();
}

%transcript_to_transcript=(); #free up some memory

my %contig_to_transcripts=();
foreach my $tr (keys %transcript_id_to_locus_id){
	my $contig=$transcript_id_to_locus_id{$tr};
	push(@{$contig_to_transcripts{$contig}}, $tr);
}
%transcript_id_to_locus_id=();
print STDERR "Done\n";

print STDERR "Comparing transcript structures...\n";
my $countTranscripts2=0;
my %transcript_introns=();
my $containerNumber=0;

my $countContigs=0;
CONTIGS: foreach my $contig (keys %contig_to_transcripts){
	$countContigs++;
	$process_manager->start and next CONTIGS;
	#print STDERR "CONTIG: $contig\n";
	my %container_to_transcripts=(); #'value' is a subset of , or equal to, 'key''s intron chain. If the reciprocal is found (i.e. both 'A' => 'B' and 'B' => 'A' exist, then A and B have the exact same intron chain.
	my %transcript_to_container=();
	my @list1=@{$contig_to_transcripts{$contig}};
	my %tr2_already_in_tr1=();
	#build introns within contig:
	%transcript_introns=();
	foreach my $tr (@list1){
		for (my $i=0; $i< $#{$transcript_exons{$tr}};$i++){
			my $intronChr=${$transcript_exons{$tr}}[$i][0];
			my $intronStrand=${$transcript_exons{$tr}}[$i][3];
			my $intronStart=${$transcript_exons{$tr}}[$i][2]+1;
			my $intronStop=${$transcript_exons{$tr}}[$i+1][1]-1;
			my @intron=($intronChr, $intronStart, $intronStop, $intronStrand);
			push(@{$transcript_introns{$tr}}, \@intron);
		}
	}

	my @list1Spliced=();
	foreach my $tr1 (@list1){
		if(exists($transcript_introns{$tr1})){
			push(@list1Spliced, $tr1);
		}
	}
	my @sortedList1Spliced= sort ({ ${$transcript_introns{$a}}[0][1] <=> ${$transcript_introns{$b}}[0][1] or ${$transcript_exons{$a}}[0][1] <=> ${$transcript_exons{$b}}[0][1] or ${$transcript_exons{$b}}[-1][2] <=> ${$transcript_exons{$a}}[-1][2] or $a cmp $b } @list1Spliced); #sort spliced transcripts by position of first intron. second and third comparisons are necessary so the script is deterministic (otherwise ties are handled randomly)
	@list1Spliced=();
	NEXTTR1: for (my $k=0; $k<=$#sortedList1Spliced; $k++){
		my $tr1=$sortedList1Spliced[$k];
		#print STDERR "SPLICED tr1 $transcript_index{$tr1}\n";
		if(exists ($transcript_to_container{$tr1})){
			$tr1=$transcript_to_container{$tr1};
			#print STDERR "tr1 IS CONTAINED in $transcript_index{$tr1}\n";
		}
		NEXTTR2: for (my $l=$k+1; $l<=$#sortedList1Spliced; $l++){
			my $tr2=$sortedList1Spliced[$l];
			if(exists ($transcript_to_container{$tr2})){
				$tr2=$transcript_to_container{$tr2};
				#print STDERR "tr2 IS CONTAINED in $transcript_index{$tr2}\n";
				next NEXTTR2;
			}
			my $overlapTranscripts=overlap(${$transcript_exons{$tr1}}[0][1],${$transcript_exons{$tr1}}[-1][2],${$transcript_exons{$tr2}}[0][1],${$transcript_exons{$tr2}}[-1][2]);  #check that tr1 and tr2 are on the same strand and overlap
			if($overlapTranscripts ==1){

				if( $transcript_strand{$tr1} == $transcript_strand{$tr2}){
					#are intron chains compatible? (ie is tr2 a subset or equal to tr1?
					my $intronTr1Index=0;
					my $countIntronsTr2MatchedToTr1=-1;
					#print STDERR "SPLICED tr2 $transcript_index{$tr2} vs tr1 $transcript_index{$tr1}\n";
					for (my $j=0; $j <= $#{$transcript_introns{$tr2}}; $j++){
						my $intronTr2=${$transcript_introns{$tr2}}[$j];
						#print STDERR " intronTr2 #$j: ${$intronTr2}[1], ${$intronTr2}[2]\n";
						for (my $i=$intronTr1Index; $i<= $#{$transcript_introns{$tr1}}; $i++){
							my $intronTr1= ${$transcript_introns{$tr1}}[$i];
							#print STDERR "  intronTr1 #$i: ${$intronTr1}[1], ${$intronTr1}[2]\n";
							my $overlap=overlap(${$intronTr1}[1], ${$intronTr1}[2], ${$intronTr2}[1], ${$intronTr2}[2]);
							#print STDERR "  overlap $overlap\n";
							if($overlap == 1){
								if(${$intronTr2}[1] == ${$intronTr1}[1] && ${$intronTr2}[2] == ${$intronTr1}[2]){
									$countIntronsTr2MatchedToTr1++;
									$intronTr1Index=$i+1; #skip directly to next $tr1 intron at the next round (next $tr2 intron)
									if($intronTr1Index > $#{$transcript_introns{$tr1}} && $j < $#{$transcript_introns{$tr2}}){ #we've reachd the last intron of tr1. Transfer remaining exons of tr2 to tr1, if they're compatible

										if(checkIntronExonOverlap($tr1,$tr2) ==0){

											$container_to_transcripts{$tr1}{$tr2}=undef ;
											$transcript_to_container{$tr2}=$tr1;
											transferRightExonsIntrons($tr1,$tr2,$j);
											adjustContainerEnds($tr1,$tr2);
											#print STDERR "MATCH\n";
											next NEXTTR2

										}
										else{
											next NEXTTR2;
										}
									}
							 		last;
								}
								else{ # introns overlap but don't exactly match, give up current tr2
									next NEXTTR2;
								}
							}
							elsif($overlap == -1){ #intron1 is downstream of intron2
								if($countIntronsTr2MatchedToTr1 == $#{$transcript_introns{$tr2}}){ # all tr2 introns have found a match in tr2
									if(checkIntronExonOverlap($tr1,$tr2) ==0){
										$container_to_transcripts{$tr1}{$tr2}=undef ;
										$transcript_to_container{$tr2}=$tr1;
										adjustContainerEnds($tr1,$tr2);
										#print STDERR "MATCH\n";
										next NEXTTR2;
									}
									else{
										next NEXTTR2;
									}
								}
								else{
									if($i==0 && $j==0){ #first intron of tr1 is downstream of first intron of tr2. Since transcripts are sorted by position of first intron, we can skip the rest of the tr2 list
										next NEXTTR1;
									}
									else{
										next NEXTTR2;
									}
								}
							}
							elsif($overlap == -2){ #intron1 is upstream of intron2
								if($i == $#{$transcript_introns{$tr1}}){ #last intron of tr1 is upstream of first intron of tr2, i.e. tr1 and tr2 are incompatible
									next NEXTTR2;
								}

							}
						}
					}
					if($countIntronsTr2MatchedToTr1 == $#{$transcript_introns{$tr2}}){ #fully identical or contained intron chain
						if(checkIntronExonOverlap($tr1,$tr2) ==0){
							$container_to_transcripts{$tr1}{$tr2}=undef ;
							$transcript_to_container{$tr2}=$tr1;
							adjustContainerEnds($tr1,$tr2);
							#print STDERR "MATCH\n";
							next NEXTTR2
						}
					}

				}
			}

			elsif($overlapTranscripts == -2){ #tr2 is downstream of tr1. Since trs are sorted by start position, we can safely skip to next tr1
				next NEXTTR1;
			}

		}
	}
	my @list1Mono=();
	#merge monoexonic reads
	foreach my $tr1 (@list1){
		unless(exists($transcript_introns{$tr1})){
			push(@list1Mono, $tr1);
		}
	}

	my @sortedList1Mono= sort ({ ${$transcript_exons{$a}}[0][1] <=> ${$transcript_exons{$b}}[0][1] or ${$transcript_exons{$a}}[0][2] <=> ${$transcript_exons{$b}}[0][2] or $a cmp $b } @list1Mono); #sort transcripts by start position of first exon
	@list1Mono=();
	NEXTTR1: for (my $k=0; $k<=$#sortedList1Mono; $k++){
		my $tr1=$sortedList1Mono[$k];
		if(exists ($transcript_to_container{$tr1})){
			$tr1=$transcript_to_container{$tr1};
			#print STDERR "IS CONTAINED in $transcript_index{$tr1}\n";
		}
		NEXTTR2: for (my $l=$k+1; $l<=$#sortedList1Mono; $l++){
			my $tr2=$sortedList1Mono[$l];
			if( $transcript_strand{$tr1} == $transcript_strand{$tr2}){
				#print STDERR "MONO $transcript_index{$tr2} vs $transcript_index{$tr1}\n";
				my $overlap=overlap(${$transcript_exons{$tr1}}[0][1],${$transcript_exons{$tr1}}[0][2],${$transcript_exons{$tr2}}[0][1],${$transcript_exons{$tr2}}[0][2]);
				#print STDERR "  overlap $overlap\n";
				if($overlap ==1){
					$container_to_transcripts{$tr1}{$tr2}=undef ;
					$transcript_to_container{$tr2}=$tr1;
					adjustContainerEnds($tr1,$tr2);
				}
				elsif($overlap == -2){ #tr2 downstream of tr1. Since transcripts are sorted by position we can skip to next tr1
					next NEXTTR1;
				}

			}
		}

	}
	@sortedList1Mono=();
	@sortedList1Spliced=();
	%transcript_introns=();

	#print all to GTF
	foreach my $tr (@list1){
		if (exists ($container_to_transcripts{$tr})){ # i.e. if tr is a container
			my @transcriptsList=();
			push(@transcriptsList, $transcript_index{$tr});
			foreach my $tr2 (keys %{$container_to_transcripts{$tr}}){
				push(@transcriptsList, $transcript_index{$tr2});
			}
			my @sortedList=sort(@transcriptsList);
			printGTF($tr, join(",", @sortedList), $contig);
		}
		else{ #tr is not a container
			unless(exists ($transcript_to_container{$tr})) { # i.e. if tr is not a container, and is not contained
				printGTF($tr, $transcript_index{$tr}, $contig);
			}
			else{ #i.e. if tr is not a container, but is contained
				#print STDERR "ERROR: transcript $tr ($transcript_index{$tr}) in contig $contig not printed in output.\n"
			}
		}
	}
	$process_manager->finish;
}
$process_manager->wait_all_children;


#print all output:
my %errorRecoveringContigGff=();
foreach my $contig (keys %contig_to_transcripts){
	my $tmpOut="$tmpdir/$contig.gff";
	open TMPOUT, "$tmpOut" or $errorRecoveringContigGff{$contig}=1;

	while(<TMPOUT>){
		print $_;
	}
	close TMPOUT;
	unlink("$tmpOut");

}

if(%errorRecoveringContigGff){
	die "ERROR: Couldn't read temp output filehandles for contigs (all corresponding transcripts are missing from output):\n".join(", ", keys %errorRecoveringContigGff);

}
print STDERR "Done.\n";

sub overlap{
	my $start1=$_[0];
	my $stop1=$_[1];
	my $start2=$_[2];
	my $stop2=$_[3];
	my $overlapValue;
	my $start2minusstop1=$start2-$stop1;
	my $start2minusstart1=$start2-$start1;
	my $stop2minusstart1=$stop2-$start1;
	my $stop2minusstop1=$stop2-$stop1;
	if( ( $stop2minusstart1>=0  && $stop2minusstop1 <=0 ) || ($start2minusstart1 >=0 && $start2minusstop1 <=0) || ($start2minusstart1 <= 0 && $stop2minusstop1 >= 0)){
		$overlapValue=1;
	}
	else{
		if($stop2minusstart1<0){
			$overlapValue=-1
		}
		elsif($start2minusstop1>0){
			$overlapValue=-2
		}
	}
	return $overlapValue; # 1  : overlap
	                      # -1 : 2 upstream of 1
	                      # -2 : 2 downstream of 1
}


sub buildContig{
	my $trA=$_[0];
	my $feature_to_feature=$_[1];
	my $feature_to_contig=$_[2];
	my $contigNumber=$_[3];

	unless(exists ${$feature_to_contig}{$trA}){
		${$feature_to_contig}{$trA}=$contigNumber;
	}
	foreach my $trB (keys %{${$feature_to_feature}{$trA}}){
		unless( exists ${$feature_to_contig}{$trB} ){
			buildContig($trB, $feature_to_feature, $feature_to_contig, $contigNumber);
		}
	}
}

sub printGTF{
	my $transcript_id=$_[0];
	my $contains=$_[1];
	my $contig=$_[2];
	my $fileOut="$tmpdir/$contig.gff";
	open TMPOUT, ">>$fileOut" or die "ERROR: Couldn't open temp output filehandle $fileOut\n";
	foreach my $exon (@{$transcript_exons{$transcript_id}}){
		my $strand='';
		if(${$exon}[3] == -1){
			$strand='-';
		}
		elsif(${$exon}[3] == 1){
			$strand='+';
		}
		elsif(${$exon}[3] == 0){
			$strand='.';
		}
		else{
			die;
		}
		my $tmId=makeTmId($transcript_id);
		print TMPOUT "${$exon}[0]\ttmerge\texon\t${$exon}[1]\t${$exon}[2]\t.\t$strand\t.\tgene_id \"$tmId\"; transcript_id \"$tmId\"; contains \"$contains\";\n";
	}
	close TMPOUT;
}

sub checkIntronExonOverlap{
#verify that when two A and B transcripts have compatible intron chains, there is no exon/intron overlap
#returns 1 if any overlap found, 0 otherwise
	my $trA=$_[0];
	my $trB=$_[1];
	if(overlap(${$transcript_exons{$trA}}[0][1],${$transcript_exons{$trA}}[$#{$transcript_exons{$trA}}][2],${$transcript_exons{$trB}}[0][1],${$transcript_exons{$trB}}[$#{$transcript_exons{$trB}}][2]) == 1){
		my @tmpExons2=@{$transcript_exons{$trB}};
		my @exons2=();
		@exons2=@tmpExons2;
		foreach my $exon2 (@exons2){
			foreach my $intron1 (@{$transcript_introns{$trA}}){
				my $overlap=overlap(${$intron1}[1], ${$intron1}[2], ${$exon2}[1], ${$exon2}[2]);
				if($overlap == 1){
					return 1;
				}
				elsif($overlap == -1){ # intron1 is downstream of exon2, we can stop and move to next exon2
					last;
				}
			}
		}

		@tmpExons2=@{$transcript_exons{$trA}};
		@exons2=@tmpExons2;
		foreach my $exon2 (@exons2){
			foreach my $intron1 (@{$transcript_introns{$trB}}){
				my $overlap=overlap(${$intron1}[1], ${$intron1}[2], ${$exon2}[1], ${$exon2}[2]);
				if($overlap == 1){
					return 1;
				}
				elsif($overlap == -1){ # intron1 is downstream of exon2, we can stop and move to next exon2
					last;
				}
			}
		}

	}
	return 0;
}



sub makeTmId{
	my $id=$_[0];
	my @newId=split("", $id);
	my @prepend=(join("",split("", $tmPrefix)),'T','M','_');
	my $totalLength=($#prepend+13)-length($id);
	for (my $i=$#prepend+1;$i<$totalLength; $i++){
		$prepend[$i]=0;
	}
	unshift(@newId, @prepend);
	return(join("",@newId))
}


sub adjustContainerEnds{
	my $tr1=$_[0];
	my $tr2=$_[1];
	if(${$transcript_exons{$tr2}}[0][1] < ${$transcript_exons{$tr1}}[0][1]){
		${$transcript_exons{$tr1}}[0][1] = ${$transcript_exons{$tr1}}[0][1]
	}
	if(${$transcript_exons{$tr2}}[-1][2] > ${$transcript_exons{$tr1}}[-1][2]){
		${$transcript_exons{$tr1}}[-1][2] = ${$transcript_exons{$tr2}}[-1][2]
	}
}

sub transferRightExonsIntrons{
	my $tr1=$_[0]; #container
	my $tr2=$_[1]; #content
	my $tr2IntronIndex=$_[2];
	my $leftmostTr2ExonToTransfer=$tr2IntronIndex+1;
	pop @{$transcript_exons{$tr1}};
	for (my $m=$leftmostTr2ExonToTransfer; $m <= $#{$transcript_exons{$tr2}} ;$m++) {
		push (@{$transcript_exons{$tr1}}, \@{${$transcript_exons{$tr2}}[$m]} );
	}
	for (my $m=$tr2IntronIndex+1; $m <= $#{$transcript_introns{$tr2}} ;$m++) {
		push (@{$transcript_introns{$tr1}}, \@{${$transcript_introns{$tr2}}[$m]} );
	}

}
