#!/usr/bin/env perl

use strict;
use warnings FATAL => 'all';
use Data::Dumper;
use UUID::Generator::PurePerl;
use Getopt::Long;
use Pod::Usage;
use Parallel::ForkManager;

no warnings 'recursion';

my $message_text  = "Error\n";
my $exit_status   = 2;          ## The exit status to use
my $verbose_level = 99;          ## The verbose level to use
my $filehandle    = \*STDERR;   ## The filehandle to write to
my $sections = "NAME|SYNOPSIS|DESCRIPTION";


=head1 NAME

tmerge

=head1 SYNOPSIS

Merge transcriptome read-to-genome alignments into non-redundant transcript models.

C<tmerge> compares transcript structures (or read-to-genome alignments) present in the input and attempts to reduce transcript redundancy, I<i.e.>, merge compatible input transcripts into non-redundant transcript models. The program treats spliced and monoexonic reads separately (i.e., those are never merged together).

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_1.png" alt="tmerge sketch" /></p>

=end HTML

See DESCRIPTION below for more details.

B<Usage example>:

C<< tmerge --cpu <number of CPUs> --tmPrefix <custom transcript_id prefix string for output GTF> <input GTF file> > <output file> >>


=head2 INPUT

GTF file of read-to-genome alignments, sorted by chromosome and start position.

Only C<exon> records are considered.
Read alignments need to be uniquely identified with the C<transcript_id> GTF attribute. C<transcript_id> is the only mandatory GTF attribute in input records.

=head2 OPTIONS

=over

=item * C<cpu> (integer) = Number of CPUs to use

B<Default>: 1

=item * C<tmPrefix> (string) = Prefix string for C<transcript_id> identifiers in the output

B<Default>: '' (empty string)

By default, output C<transcript_id>s consist in arbitrary "C<TM_XXXXXXXXXXXX>" strings. If C<tmPrefix> is set, its value will prefix all C<transcript_id> strings in the GTF output.

=item * C<minReadSupport> (integer) = required minimum number of reads supporting a transcript model. When building a transcript model, only the reads fulfilling the following conditions are considered:

For B<spliced transcripts>, at least C<minReadSupport> input reads must share a given intron chain and 5' + 3' ends (+/- C<exonOverhangTolerance> bases, see below).

For B<mono-exonic transcripts>, at least C<minReadSupport> input reads must share their 5' + 3' ends (+/- C<exonOverhangTolerance> bases, see below). In other words, when C<exonOverhangTolerance> C< = 0> (the default), only monoexonic reads with identical genome coordinates are merged.

B<Default>: 1

=item * C<exonOverhangTolerance> (integer) = maximum number of nucleotides of terminal exon overhang allowed during the merging of input reads. More specifically, the value of C<exonOverhangTolerance> affects the following aspects of merging:

=over

=item * Tolerated overhang ("fuzziness") of 5' and 3' ends for two reads to be considered equivalent when calculating read support (see C<minReadSupport> option above)

=item * Tolerated overhang of the terminal exon of a shorter read over the splice site of a longer one. See explanation in "DESCRIPTION" below.



=back

B<Default>: 0 (i.e., no exon overhang allowed)

=back

=head2 OUTPUT

C<tmerge> outputs non-redundant transcript models (B<TMs>) in GTF format. Each TM entry is uniquely identified by its (arbitrary) C<transcript_id> attribute.

The C<gene_id> attribute has the same value as C<transcript_id> by convention; it is therefore meaningless.

Two extra GTF attributes are present:

=over

=item * C<contains>: comma-separated list of input reads (C<transcript_id>s) contained in the corresponding TM, sorted by descending genomic size.

=item * C<longest>: comma separated list of the longest read(s) (C<transcript_id>s) contained in the corresponding TM. This list contains more that one item only in case of length ties. Note that the reads reported do not necessarily cover the entire length of the resulting TM.

=back

The B<'score'> column (6th field) reports the number of input reads the TM contains.

=head1 DESCRIPTION

C<tmerge> reduces redundancy in a set of transcriptome read-to-genome alignments. It does so by looking for reads with I<B<compatible>> aligned structures in the input, and merging those into I<B<Transcript Models>> (B<TMs>).

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_1.png" alt="tmerge sketch" /></p>

=end HTML

Pairwise B<compatibility> between aligned structures is evaluated using the following rules:

=over

=item * If both structures are B<spliced>, they are deemed compatible if:

=over

=item * 1. at least one of their exons overlap on the same genomic strand,

=item * 2. either their intron chains are equal, or one is an exact subset of the other,

and

=item * 3. there is no overlap between an exon of one structure and an intron of the other.

=back

Condition (2) means that C<tmerge> will never artificially extend intron chains:

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_non_merge.png" alt="tmerge non-merge case" /></p>

=end HTML

=item * If both structures are B<monoexonic>, they are considered compatible if they overlap by at least 1 nucleotide on the same genomic strand.

=item * If one structure is B<spliced> and the other B<monoexonic>, they are not merged.

=back


All pairs of compatible structures are then merged recursively into the longest possible TM.

=head2 C<exonOverhangTolerance> option and splice sites

Setting this option to a positive integer can correct mismapped splice junctions that sometimes occur when aligning very short, error-rich terminal read exons:


=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_FalseExonOverhang.300dpi.png" alt="tmerge FalseExonOverhang sketch" /></p>

=end HTML

The setting works as explained below:

=begin HTML

<p><img src="http://public-docs.crg.es/rguigo/CLS/img/tmerge_exonOverhangTolerance.300dpi.png" alt="tmerge exonOverhangTolerance sketch" /></p>

=end HTML

B<WARNING>: this option also affects how read support is calculated (see OPTIONS above)


=head1 DEPENDENCIES

=over

=item * UUID::Generator::PurePerl

Install (bash): C<< $ cpanm UUID::Generator::PurePerl >>

=item * Parallel::ForkManager

Install (bash): C<< $ cpanm Parallel::ForkManager >>

=back

(When using C<cpanm> you might need to use the C<--local-lib> option if you don't have admin rights, see documentation).


=head1 AUTHOR

Julien Lagarde, CRG, Barcelona, contact julienlag@gmail.com

=cut



my $tmPrefix='';
my $cpu=0;
my $minReadSupport=1;
my $exonOverhangTolerance=0;
my $debug='';
GetOptions ('tmPrefix=s' => \$tmPrefix,
            'cpu=i' => \$cpu,
            'minReadSupport=i' => \$minReadSupport,
            'exonOverhangTolerance=i' => \$exonOverhangTolerance,
            'debug' => \$debug,
            )
or pod2usage( { -message => "Error in command line arguments",
        		  -exitval => $exit_status  ,
            		-verbose => $verbose_level,
               -output  => $filehandle } );

unless (defined $ARGV[0]){
	pod2usage( { -message => "Error in command line arguments: no input provided.",
        		  -exitval => $exit_status  ,
            		-verbose => $verbose_level,
               -output  => $filehandle } );
}

die "minReadSupport value must be > 0, can't continue.\n" if $minReadSupport<1;

my $tmpdir="/tmp/";
if(exists $ENV{'TMPDIR'}){
	$tmpdir=$ENV{'TMPDIR'};
}
my $usedCpus;
if ($cpu == 0){
	$usedCpus=1
}
else{
	$usedCpus=$cpu;
}
print STDERR "######################################################################################################################
######################################################################################################################
##
";

print STDERR "##    Parameters/environment information:\n";
print STDERR "##\n";
print STDERR "##    - Using TMP DIR: $tmpdir (edit the TMPDIR environment variable to change that)\n";
print STDERR "##    - Minimum read support required per merged transcript model: $minReadSupport\n";
print STDERR "##    - Exon overhang tolerance when merging: $exonOverhangTolerance bases\n";
print STDERR "##    - Will use $usedCpus CPUs\n";
print STDERR "##\n";
print STDERR "######################################################################################################################
######################################################################################################################
";

my $process_manager = Parallel::ForkManager->new($cpu);

my $sortedGff;
if(defined($ARGV[0])){
	$sortedGff=$ARGV[0];
}
else{
	die "Need input GTF file name as argument.\n";
}

open GFF, "$sortedGff" or die $!;

my %transcript_to_transcript=();
my %transcript_exons=();
my %transcript_chr=();
my %transcript_strand=();
my $previous_start=-1;
my $previous_chr='Caravaggio';
my $previous_transcript='Picasso';
my $superExonStart=-1;
my $superExonStop=-1;
my %transcript_id_index=();

print STDERR "Parsing GTF input...\n";
my $nr_exons=0;
my $transcript_count=0;
my %transcript_seen=();
my %transcript_index=();
my %transcript_rev_index=();
while (<GFF>){
	next if ($_=~/^#/);
	next unless ($_=~/\texon\t/);
	if ($_=~/^(\S+)\t(\S+)\t(\S+)\t(\d+)\t(\d+)\t\S+\t(\S+)\t\S+\t.*transcript_id "(\S+)?";/){
		if ($3 eq "exon"){
			$nr_exons++;
			my $GTFtranscript_id=$7;
			my $chr=$1;
			my $start=$4;
			my $stop=$5;
			my $str=$6;
			my $strand;
			if($str eq '+'){
				$strand=1;
			}
			elsif($str eq '-'){
				$strand=-1;
			}
			elsif($str eq '.'){
				$strand=0;
			}
			else{
				die "Unrecognized strand value '$str' at line $.\n";
			}
			unless(exists $transcript_seen{$GTFtranscript_id}){
				$transcript_count++;
				$transcript_seen{$GTFtranscript_id}=undef;
				$transcript_index{$transcript_count}=$GTFtranscript_id;
				$transcript_rev_index{$GTFtranscript_id}=$transcript_count;
			}

			my $transcript_id=$transcript_rev_index{$GTFtranscript_id};
			#Check for sorted input:
			die "ERROR: Unsorted GTF input (line $.). Must be sorted by chr, then start, then stop. Can't continue.\n" if ($chr eq $previous_chr && $start < $previous_start);
			$transcript_strand{$transcript_id}=$strand;
			$transcript_chr{$transcript_id}=$chr;
			my @exon=($chr, $start, $stop, $strand);
			push(@{$transcript_exons{$transcript_id}}, \@exon);
			$transcript_to_transcript{$transcript_id}{$transcript_id}=undef;
			my $overlapWithPrevious=overlap($superExonStart, $superExonStop, $start, $stop);
			if ($chr eq $previous_chr && $overlapWithPrevious == 1){
				$transcript_to_transcript{$transcript_id}{$previous_transcript}=undef;
				$transcript_to_transcript{$previous_transcript}{$transcript_id}=undef;
				if($stop > $superExonStop){
					$superExonStop = $stop;
				}
			}

			else{
				#re-initialize superExon
				$previous_chr=$chr;
				$superExonStart=$start;
				$superExonStop=$stop;
			}
			$previous_transcript=$transcript_id;
			$previous_start=$start;
		}
	}
	else{
		die "ERROR: line $.: malformed GTF record. Can't continue.\n";

	}

}
close GFF;
print STDERR "Done. Found $nr_exons exons and $transcript_count transcripts.\n";
%transcript_seen=();
%transcript_rev_index=();

print STDERR "Building contigs (sets of overlapping transcripts)...\n";

my $ug = UUID::Generator::PurePerl->new();
my $locusNumber = $ug->generate_v1();
my %transcript_id_to_locus_id=();
foreach my $tr1 (keys %transcript_to_transcript){
	buildContig($tr1, \%transcript_to_transcript, \%transcript_id_to_locus_id, $locusNumber);
	#generate UUID for contig (this is to write temp files):
	my $ug = UUID::Generator::PurePerl->new();
    $locusNumber = $ug->generate_v1();
}

%transcript_to_transcript=(); #free up some memory

my %contig_to_transcripts=();
foreach my $tr (keys %transcript_id_to_locus_id){
	my $contig=$transcript_id_to_locus_id{$tr};
	push(@{$contig_to_transcripts{$contig}}, $tr);
}
%transcript_id_to_locus_id=();
my $nrContigs=scalar(keys %contig_to_transcripts);
print STDERR "Done. Built $nrContigs contigs.\n";

print STDERR "Comparing transcript structures...\n";
my %transcript_introns=();

CONTIGS: foreach my $contig (sort { scalar(@{$contig_to_transcripts{$b}}) <=> scalar(@{$contig_to_transcripts{$a}}) } keys %contig_to_transcripts){ #sort contigs by size so we start with the biggest ones (useful if cpus>1)
	#print STDERR "Processing contig $contig (contains ".scalar(@{$contig_to_transcripts{$contig}})." transcripts)\n";
	$process_manager->start and next CONTIGS;
	#print STDERR "CONTIG: $contig\n";

	my %intronChainToTranscripts=();
	my %container_to_transcripts=(); #'value' is a subset of , or equal to, 'key''s intron chain. If the reciprocal is found (i.e. both 'A' => 'B' and 'B' => 'A' exist, then A and B have the exact same intron chain.
	my %transcript_to_container=();
	my @list1=@{$contig_to_transcripts{$contig}};
	#build introns within contig:
	%transcript_introns=();
	my @list1Spliced=();
	foreach my $tr (@list1){
		for (my $i=0; $i< $#{$transcript_exons{$tr}};$i++){
			my $intronChr=${$transcript_exons{$tr}}[$i][0];
			my $intronStrand=${$transcript_exons{$tr}}[$i][3];
			my $intronStart=${$transcript_exons{$tr}}[$i][2]+1;
			my $intronStop=${$transcript_exons{$tr}}[$i+1][1]-1;
			my @intron=($intronChr, $intronStart, $intronStop, $intronStrand);
			push(@{$transcript_introns{$tr}}, \@intron);
		}
		if (exists $transcript_introns{$tr}){
			my $intronChainId=makeIntronChainId(\@{$transcript_introns{$tr}});
			push(@{$intronChainToTranscripts{$intronChainId}}, $tr);

		}
	}
	if($minReadSupport>1){
		foreach my $tr1 (@list1){
	#		print STDERR "$transcript_index{$tr1} \n";
			if(exists ($transcript_introns{$tr1})){
				my $supportCount=0;
				my $trIntronChainId=makeIntronChainId(\@{$transcript_introns{$tr1}});
				if($#{$intronChainToTranscripts{$trIntronChainId}} +1 >=$minReadSupport){
	#				print STDERR "PASSED intron chain support\n";
					foreach my $tr2(@{$intronChainToTranscripts{$trIntronChainId}}){
	#					print STDERR " $transcript_index{$tr2} \n";

						if( (${$transcript_exons{$tr2}}[0][1] >= ${$transcript_exons{$tr1}}[0][1] - $exonOverhangTolerance
						      &&
						      ${$transcript_exons{$tr2}}[0][1] <= ${$transcript_exons{$tr1}}[0][1] + $exonOverhangTolerance)
						      &&
						      (${$transcript_exons{$tr2}}[-1][2] >= ${$transcript_exons{$tr1}}[-1][2] - $exonOverhangTolerance
						      &&
						      ${$transcript_exons{$tr2}}[-1][2] <= ${$transcript_exons{$tr1}}[-1][2] + $exonOverhangTolerance) ) {
	#						print STDERR "  MATCH\n";
							$supportCount++;

						}
						else{

	#						print STDERR "  NOMATCH\n";
						}
					}
				}
	#			print STDERR "$transcript_index{$tr1} support $supportCount\n";
				if($supportCount>=$minReadSupport){
	#				print STDERR "OK list1Spliced\n";
					push(@list1Spliced, $tr1);
				}

			}

		}
	}
	else{
		foreach my $tr1 (@list1){
	#		print STDERR "$transcript_index{$tr1} \n";
			if(exists ($transcript_introns{$tr1})){
				push(@list1Spliced, $tr1);
			}
		}
	}
	%intronChainToTranscripts=();
	my @sortedList1Spliced= sort ({ ${$transcript_introns{$a}}[0][1] <=> ${$transcript_introns{$b}}[0][1] or ${$transcript_exons{$a}}[0][1] <=> ${$transcript_exons{$b}}[0][1] or ${$transcript_exons{$b}}[-1][2] <=> ${$transcript_exons{$a}}[-1][2] or $a cmp $b } @list1Spliced); #sort spliced transcripts by position of first intron. second and third comparisons are necessary so the script is deterministic (otherwise ties are handled randomly)
	@list1Spliced=();
	NEXTTR1: for (my $k=0; $k<=$#sortedList1Spliced; $k++){
		my $tr1=$sortedList1Spliced[$k];
		print STDERR "DEBUG: tr1 $transcript_index{$tr1}\n" if $debug;
		if(exists ($transcript_to_container{$tr1})){
			$tr1=$transcript_to_container{$tr1};
			print STDERR "DEBUG: tr1 IS CONTAINED in $transcript_index{$tr1}\n" if $debug;
		}

		NEXTTR2: for (my $l=$k+1; $l<=$#sortedList1Spliced; $l++){
			my $tr2=$sortedList1Spliced[$l];
			print STDERR "DEBUG:  tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2}\n" if $debug;

		#print STDERR "SPLICED tr1 $transcript_index{$tr1} tr2 $transcript_index{$tr2}\n";
			if(exists ($transcript_to_container{$tr2})){
				#$tr2=$transcript_to_container{$tr2};
				print STDERR "DEBUG:  tr2 IS CONTAINED in $transcript_index{$tr2}\n" if $debug;
				next NEXTTR2;
			}
			my $tr1IntronChainId=makeIntronChainId(\@{$transcript_introns{$tr1}});
			my $tr2IntronChainId=makeIntronChainId(\@{$transcript_introns{$tr2}});
			if ($tr1IntronChainId eq $tr2IntronChainId){
				$container_to_transcripts{$tr1}{$tr2}=undef ;
				$transcript_to_container{$tr2}=$tr1;
				adjustContainerEnds($tr1,$tr2);
				print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} MATCH 1\n" if $debug;
				next NEXTTR2
			}
			my $overlapTranscripts=overlap(${$transcript_exons{$tr1}}[0][1],${$transcript_exons{$tr1}}[-1][2],${$transcript_exons{$tr2}}[0][1],${$transcript_exons{$tr2}}[-1][2]);  #check that tr1 and tr2 are on the same strand and overlap
			if($overlapTranscripts ==1){

				if( $transcript_strand{$tr1} == $transcript_strand{$tr2}){
					#are intron chains compatible? (ie is tr2 a subset or equal to tr1?
					my $intronTr1Index=0;
					my $countIntronsTr2MatchedToTr1=-1;
					my $firstTr1IntronMatchedToTr2;
					my $lastTr1IntronMatchedToTr2;
					for (my $j=0; $j <= $#{$transcript_introns{$tr2}}; $j++){
						my $intronTr2=${$transcript_introns{$tr2}}[$j];
						print STDERR "DEBUG:   intronTr2 #$j: ${$intronTr2}[1], ${$intronTr2}[2]\n" if $debug;
						for (my $i=$intronTr1Index; $i<= $#{$transcript_introns{$tr1}}; $i++){
							my $intronTr1= ${$transcript_introns{$tr1}}[$i];
							print STDERR "DEBUG:    intronTr1 #$i: ${$intronTr1}[1], ${$intronTr1}[2]\n" if $debug;
							my $overlap=overlap(${$intronTr1}[1], ${$intronTr1}[2], ${$intronTr2}[1], ${$intronTr2}[2]);
							print STDERR "DEBUG:     overlap $overlap\n" if $debug;
							if($overlap == 1){
								if(${$intronTr2}[1] == ${$intronTr1}[1] && ${$intronTr2}[2] == ${$intronTr1}[2]){
									$countIntronsTr2MatchedToTr1++;
									if($j==0){
										$firstTr1IntronMatchedToTr2=$i;
									}
									if($j==$#{$transcript_introns{$tr2}}){
										$lastTr1IntronMatchedToTr2=$i;
									}
									$intronTr1Index=$i+1; #skip directly to next $tr1 intron at the next round (next $tr2 intron)
									if($intronTr1Index > $#{$transcript_introns{$tr1}} #we've reached the last intron of tr1.
										&& $j < $#{$transcript_introns{$tr2}} #we've not reached the last intron of tr2.
										&& ${$transcript_introns{$tr1}}[0][1] == ${$transcript_introns{$tr2}}[0][1] #tr1 and tr2's respective intron chains start at the same coord
										&& ${$transcript_introns{$tr2}}[$j+1][1] >= ${$transcript_exons{$tr1}}[-1][2] - $exonOverhangTolerance){ #tr1's last exon does not overhang too much inside tr2's next intron
										#Transfer remaining exons of tr2 to tr1, if they're compatible
										$lastTr1IntronMatchedToTr2=$i;
										print STDERR "DEBUG:     reached last tr1 intron\n" if $debug;
										if(checkIntronExonOverlap($tr1,$tr2,$firstTr1IntronMatchedToTr2,$lastTr1IntronMatchedToTr2) ==0){

											$container_to_transcripts{$tr1}{$tr2}=undef ;
											$transcript_to_container{$tr2}=$tr1;
											transferRightExonsIntrons($tr1,$tr2,$j);
											adjustContainerEnds($tr1,$tr2);
											print STDERR "DEBUG:     tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} MATCH 2\n" if $debug;
											next NEXTTR2

										}
										else{
											print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 2\n" if $debug;
											next NEXTTR2;
										}
									}
							 		last;
								}
								else{ # introns overlap but don't exactly match, give up current tr2
									print STDERR "DEBUG:    tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 3\n" if $debug;
									next NEXTTR2;
								}
							}
							elsif($overlap == -1){ #intron1 is downstream of intron2
								if($countIntronsTr2MatchedToTr1 == $#{$transcript_introns{$tr2}}){ # all tr2 introns have found a match in tr1
									print STDERR "DEBUG:    YES 1" if $debug;
									if(checkIntronExonOverlap($tr1,$tr2,$firstTr1IntronMatchedToTr2,$lastTr1IntronMatchedToTr2) ==0){
										$container_to_transcripts{$tr1}{$tr2}=undef ;
										$transcript_to_container{$tr2}=$tr1;
										adjustContainerEnds($tr1,$tr2);
										print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} MATCH 3\n" if $debug;
										next NEXTTR2;
									}
									else{
										print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 4\n" if $debug;
										next NEXTTR2;
									}
								}
								else{

									if($i==0 && $j==0){ #first intron of tr1 is downstream of first intron of tr2. Since transcripts are sorted by position of first intron, we can skip the rest of the tr2 list
										print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 5\n" if $debug;
										next NEXTTR1;
									}
									else{
										print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 6\n" if $debug;
										next NEXTTR2;
									}
								}
							}
							elsif($overlap == -2){ #intron1 is upstream of intron2
								if($i == $#{$transcript_introns{$tr1}} || $j > 0 ){ #last intron of tr1 is upstream of first intron of tr2, i.e. tr1 and tr2 are incompatible
									print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 7\n" if $debug;
									next NEXTTR2;
								}

							}
						}
					}
					if($countIntronsTr2MatchedToTr1 == $#{$transcript_introns{$tr2}}){ #fully identical or contained intron chain
						#print STDERR "##c $firstTr1IntronMatchedToTr2 $lastTr1IntronMatchedToTr2\n";
						print STDERR "DEBUG:    YES 2\n" if $debug;
						if(checkIntronExonOverlap($tr1,$tr2,$firstTr1IntronMatchedToTr2,$lastTr1IntronMatchedToTr2) ==0){
							$container_to_transcripts{$tr1}{$tr2}=undef ;
							$transcript_to_container{$tr2}=$tr1;
							adjustContainerEnds($tr1,$tr2);
							print STDERR "DEBUG:    tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} MATCH 4\n" if $debug;
							next NEXTTR2
						}
					}
					else{
						print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 9\n" if $debug;

					}

				}
			}

			elsif($overlapTranscripts == -2){ #tr2 is downstream of tr1. Since trs are sorted by start position, we can safely skip to next tr1
				print STDERR "DEBUG:   tr1 $transcript_index{$tr1} vs tr2 $transcript_index{$tr2} INCOMP 10\n" if $debug;
				next NEXTTR1;
			}

		}
	}
	my @list1Mono=();
	my @list1MonoSupported=();
	#merge monoexonic reads
	foreach my $tr1 (@list1){
		unless(exists($transcript_introns{$tr1})){
			push(@list1Mono, $tr1);
		}
	}
	my @list1MonoSorted=sort { ${$transcript_exons{$a}}[0][1] <=> ${$transcript_exons{$b}}[0][1] or ${$transcript_exons{$a}}[0][2] <=> ${$transcript_exons{$b}}[0][2] } @list1Mono;
	@list1Mono=();
	if($minReadSupport>1){
		NEXTTR1: foreach my $tr1 (@list1MonoSorted) {
			my $supportCount=0;
			#print STDERR "$transcript_index{$tr1} list1MonoSupported?\n";
			NEXTTR2: foreach my $tr2 (@list1MonoSorted){
			#	print STDERR " $transcript_index{$tr2}\n";
				if( $transcript_strand{$tr1} == $transcript_strand{$tr2}){
					my $overlap=overlap(${$transcript_exons{$tr1}}[0][1],${$transcript_exons{$tr1}}[0][2],${$transcript_exons{$tr2}}[0][1],${$transcript_exons{$tr2}}[0][2]);
					if($overlap ==1 && (${$transcript_exons{$tr2}}[0][1] >= ${$transcript_exons{$tr1}}[0][1] - $exonOverhangTolerance
					      &&
					      ${$transcript_exons{$tr2}}[0][1] <= ${$transcript_exons{$tr1}}[0][1] + $exonOverhangTolerance)
					      &&
					      (${$transcript_exons{$tr2}}[-1][2] >= ${$transcript_exons{$tr1}}[-1][2] - $exonOverhangTolerance
					      &&
					      ${$transcript_exons{$tr2}}[-1][2] <= ${$transcript_exons{$tr1}}[-1][2] + $exonOverhangTolerance) ) {
						$supportCount++;
			#			print STDERR " support $supportCount\n";
					}
					elsif($overlap == -2){ #tr2 downstream of tr1. Since transcripts are sorted by position we can skip to next tr1
						if($supportCount>=$minReadSupport){
			#				print STDERR "OK list1MonoSupported\n";
							push(@list1MonoSupported, $tr1);
						}
						next NEXTTR1;
					}
				}

			}
			if($supportCount>=$minReadSupport){
			#	print STDERR "OK list1MonoSupported\n";
				push(@list1MonoSupported, $tr1);
			}

		}
	}
	else{
		@list1MonoSupported=@list1MonoSorted;
	}

	my @sortedList1Mono=@list1MonoSupported; #sort transcripts by start position of first exon
	@list1MonoSupported=();

	NEXTTR1: for (my $k=0; $k<=$#sortedList1Mono; $k++){
		my $tr1=$sortedList1Mono[$k];
		if(exists ($transcript_to_container{$tr1})){
			$tr1=$transcript_to_container{$tr1};
			#print STDERR "IS CONTAINED in $transcript_index{$tr1}\n";
		}
		NEXTTR2: for (my $l=$k+1; $l<=$#sortedList1Mono; $l++){
			my $tr2=$sortedList1Mono[$l];
			if(exists ($transcript_to_container{$tr2})){
				#$tr2=$transcript_to_container{$tr2};
				#print STDERR "tr2 IS CONTAINED in $transcript_index{$tr2}\n";
#				print STDERR "NO 1\n";
				next NEXTTR2;
			}
			if( $transcript_strand{$tr1} == $transcript_strand{$tr2}){
				#print STDERR "MONO $transcript_index{$tr2} vs $transcript_index{$tr1}\n";
				my $overlap=overlap(${$transcript_exons{$tr1}}[0][1],${$transcript_exons{$tr1}}[0][2],${$transcript_exons{$tr2}}[0][1],${$transcript_exons{$tr2}}[0][2]);
				#print STDERR "  overlap $overlap\n";
				if($overlap ==1){
					$container_to_transcripts{$tr1}{$tr2}=undef ;
					$transcript_to_container{$tr2}=$tr1;
					adjustContainerEnds($tr1,$tr2);
				}
				elsif($overlap == -2){ #tr2 downstream of tr1. Since transcripts are sorted by position we can skip to next tr1
					next NEXTTR1;
				}

			}
		}

	}
	%transcript_introns=();

	#print all to GTF
	foreach my $tr (@sortedList1Spliced){
		if (exists ($container_to_transcripts{$tr})){ # i.e. if tr is a container
			my @trList= sort { ${$transcript_exons{$b}}[-1][2] - ${$transcript_exons{$b}}[0][1] <=> ${$transcript_exons{$a}}[-1][2] - ${$transcript_exons{$a}}[0][1] } (keys (%{$container_to_transcripts{$tr}}), $tr); # sort by genomic length
			my @longest=();
			my $longestTMlength=0;
			#push(@transcriptsList, $transcript_index{$tr});
			for (my $i=0;$i<=$#trList;$i++){
				my $t=$trList[$i];
				if($i==0){
					$longestTMlength=${$transcript_exons{$t}}[-1][2] - ${$transcript_exons{$t}}[0][1];
				}
				if(${$transcript_exons{$t}}[-1][2] - ${$transcript_exons{$t}}[0][1] == $longestTMlength){
					push(@longest, $transcript_index{$t});
				}
			}
#			foreach my $tr2 (sort { ${$transcript_exons{$b}}[-1][2] - ${$transcript_exons{$b}}[0][1] <=> ${$transcript_exons{$a}}[-1][2] - ${$transcript_exons{$a}}[0][1] } (keys (%{$container_to_transcripts{$tr}}), $tr) ){  # sort by genomic length
#				push(@transcriptsList, $transcript_index{$tr2});
#				if(${$transcript_exons{$tr2}}[-1][2] - ${$transcript_exons{$tr2}}[0][1] > $longestTM){

#				}

			#my @sortedList=sort(@transcriptsList);
			my @transcriptsList=();
			foreach my $t (@trList){
				push(@transcriptsList, $transcript_index{$t})
			}
			printGTF($tr, scalar(@transcriptsList), join(",", @transcriptsList), join(",", @longest), $contig);
#			printGTF($tr, join(",", @sortedList), $contig);
		}
		else{ #tr is not a container
			unless(exists ($transcript_to_container{$tr})) { # i.e. if tr is not a container, and is not contained
				printGTF($tr, 1, $transcript_index{$tr}, $transcript_index{$tr}, $contig);
			}
			#else{ #i.e. if tr is not a container, but is contained
				#print STDERR "ERROR: transcript $tr ($transcript_index{$tr}) in contig $contig not printed in output.\n"
			#}
		}
	}

	foreach my $tr (@sortedList1Mono){
		if (exists ($container_to_transcripts{$tr})){ # i.e. if tr is a container
			my @trList= sort { ${$transcript_exons{$b}}[-1][2] - ${$transcript_exons{$b}}[0][1] <=> ${$transcript_exons{$a}}[-1][2] - ${$transcript_exons{$a}}[0][1] } (keys (%{$container_to_transcripts{$tr}}), $tr); # sort by genomic length
			if ($#trList>=$minReadSupport-1){
				my @longest=();
				my $longestTMlength=0;
				for (my $i=0;$i<=$#trList;$i++){
					my $t=$trList[$i];
					if($i==0){
						$longestTMlength=${$transcript_exons{$t}}[-1][2] - ${$transcript_exons{$t}}[0][1];
					}
					if(${$transcript_exons{$t}}[-1][2] - ${$transcript_exons{$t}}[0][1] == $longestTMlength){
						push(@longest, $transcript_index{$t});
					}
				}
				my @transcriptsList=();
				foreach my $t (@trList){
					push(@transcriptsList, $transcript_index{$t})
				}
				printGTF($tr, scalar(@transcriptsList), join(",", @transcriptsList), join(",", @longest), $contig);
			}

		}
		elsif($minReadSupport<2){ #tr is not a container
			unless(exists ($transcript_to_container{$tr})) { # i.e. if tr is not a container, and is not contained
				printGTF($tr, 1, $transcript_index{$tr}, $transcript_index{$tr}, $contig);

			}
			#else{ #i.e. if tr is not a container, but is contained
				#print STDERR "ERROR: transcript $tr ($transcript_index{$tr}) in contig $contig not printed in output.\n"
			#}
		}
	}

	$process_manager->finish;
}
$process_manager->wait_all_children;


#print all output:
my %errorRecoveringContigGff=();
foreach my $contig (keys %contig_to_transcripts){
	my $tmpOut="$tmpdir/$contig.gff";
	if(-e $tmpOut){
		open TMPOUT, "$tmpOut" or $errorRecoveringContigGff{$contig}=1;

		while(<TMPOUT>){
			print $_;
		}
		close TMPOUT;
		unlink("$tmpOut");
	}
}

if(%errorRecoveringContigGff){
 	print STDERR "No data output for contig(s):\n";
 	foreach my $contig (keys %errorRecoveringContigGff){
 		foreach my $tr (@{$contig_to_transcripts{$contig}}){
 			print STDERR "Contig: $contig Transcript: $transcript_id_index{$tr}\n";
 		}
 	}

}
print STDERR "Done.\n";



sub makeIntronChainId{
	my @a=@{$_[0]};
	my $s='';
	foreach my $i (@a){
		$s.=".".join(".", @{$i})
	}
	return $s;
}


sub overlap{
	my $start1=$_[0];
	my $stop1=$_[1];
	my $start2=$_[2];
	my $stop2=$_[3];
	my $overlapValue;
	my $start2minusstop1=$start2-$stop1;
	my $start2minusstart1=$start2-$start1;
	my $stop2minusstart1=$stop2-$start1;
	my $stop2minusstop1=$stop2-$stop1;
	if( ( $stop2minusstart1>=0  && $stop2minusstop1 <=0 ) || ($start2minusstart1 >=0 && $start2minusstop1 <=0) || ($start2minusstart1 <= 0 && $stop2minusstop1 >= 0)){
		$overlapValue=1;
	}
	else{
		if($stop2minusstart1<0){
			$overlapValue=-1
		}
		elsif($start2minusstop1>0){
			$overlapValue=-2
		}
	}
	return $overlapValue; # 1  : overlap
	                      # -1 : 2 upstream of 1
	                      # -2 : 2 downstream of 1
}


sub buildContig{
	my $trA=$_[0];
	my $feature_to_feature=$_[1];
	my $feature_to_contig=$_[2];
	my $contigNumber=$_[3];

	unless(exists ${$feature_to_contig}{$trA}){
		${$feature_to_contig}{$trA}=$contigNumber;
	}
	foreach my $trB (keys %{${$feature_to_feature}{$trA}}){
		unless( exists ${$feature_to_contig}{$trB} ){
			buildContig($trB, $feature_to_feature, $feature_to_contig, $contigNumber);
		}
	}
}

sub printGTF{
	my $transcript_id=$_[0];
	my $score=$_[1];
	my $contains=$_[2];
	my $longest=$_[3];
	my $contig=$_[4];
	my $fileOut="$tmpdir/$contig.gff";
	open TMPOUT, ">>$fileOut" or die "ERROR: Couldn't open temp output filehandle $fileOut\n";
	foreach my $exon (@{$transcript_exons{$transcript_id}}){
		my $strand='';
		if(${$exon}[3] == -1){
			$strand='-';
		}
		elsif(${$exon}[3] == 1){
			$strand='+';
		}
		elsif(${$exon}[3] == 0){
			$strand='.';
		}
		else{
			die;
		}
		my $tmId=makeTmId($transcript_id);
		print TMPOUT "${$exon}[0]\ttmerge\texon\t${$exon}[1]\t${$exon}[2]\t$score\t$strand\t.\tgene_id \"$tmId\"; transcript_id \"$tmId\"; contains \"$contains\"; longest \"$longest\";\n";
	}
	close TMPOUT;
}

sub checkIntronExonOverlap{
#verify that when two A and B transcripts have compatible intron chains, there is no terminal exon/intron overlap
#returns 1 if any overlap found, 0 otherwise
	my $trA=$_[0];
	my $trB=$_[1];
	my $firstTrAIntronMatchedToTrB=$_[2];
	my $lastTrAIntronMatchedToTrB=$_[3];
	unless (defined $firstTrAIntronMatchedToTrB){
		die "firstTrAIntronMatchedToTrB is undefined for $transcript_index{$trA} / $transcript_index{$trB}\n";
	}
	unless (defined $lastTrAIntronMatchedToTrB){
		die "lastTrAIntronMatchedToTrB is undefined for $transcript_index{$trA} / $transcript_index{$trB}\n";

	}
		my @exons2=(${$transcript_exons{$trB}}[0],${$transcript_exons{$trB}}[-1]); #only terminal exons
		for (my $i=0; $i<=$#exons2;$i++) {
			my $exon2=$exons2[$i];
			if($i==0){ #first exon of trB
				unless ($firstTrAIntronMatchedToTrB ==0) { # if the first intron of trA matched to trB is trA[0], no need to look for upstream introns on trA

					my $intron1=${$transcript_introns{$trA}}[$firstTrAIntronMatchedToTrB-1];
					#my $overlap=overlap(${$intron1}[1], ${$intron1}[2], ${$exon2}[1], ${$exon2}[2]);
					if( ${$exon2}[1] <= ${$intron1}[2] - $exonOverhangTolerance){
						return 1;
					}
				}
			}
			elsif($i==1){ #last exon of trB
				unless ($lastTrAIntronMatchedToTrB == $#{$transcript_introns{$trA}} ){ # if the last intron of trA matched to trB is trA[-1], no need to look for downstream introns on trA
					my $intron1=${$transcript_introns{$trA}}[$lastTrAIntronMatchedToTrB+1];
					#my $overlap=overlap(${$intron1}[1], ${$intron1}[2], ${$exon2}[1], ${$exon2}[2]);
					if(${$exon2}[2] >= ${$intron1}[1] + $exonOverhangTolerance){
						return 1;
					}
				}
			}
			else{
				die;
			}

		}

	return 0;
}



sub makeTmId{
	my $id=$_[0];
	my @newId=split("", $id);
	my @prepend=(join("",split("", $tmPrefix)),'T','M','_');
	my $totalLength=($#prepend+13)-length($id);
	for (my $i=$#prepend+1;$i<$totalLength; $i++){
		$prepend[$i]=0;
	}
	unshift(@newId, @prepend);
	return(join("",@newId))
}


sub adjustContainerEnds{
	my $tr1=$_[0];
	my $tr2=$_[1];
	if(${$transcript_exons{$tr2}}[0][1] < ${$transcript_exons{$tr1}}[0][1]){
		${$transcript_exons{$tr1}}[0][1] = ${$transcript_exons{$tr1}}[0][1]
	}
	if(${$transcript_exons{$tr2}}[-1][2] > ${$transcript_exons{$tr1}}[-1][2]){
		${$transcript_exons{$tr1}}[-1][2] = ${$transcript_exons{$tr2}}[-1][2]
	}
}

sub transferRightExonsIntrons{
	my $tr1=$_[0]; #container
	my $tr2=$_[1]; #content
	my $tr2IntronIndex=$_[2];
	my $leftmostTr2ExonToTransfer=$tr2IntronIndex+1;
	pop @{$transcript_exons{$tr1}};
	for (my $m=$leftmostTr2ExonToTransfer; $m <= $#{$transcript_exons{$tr2}} ;$m++) {
		push (@{$transcript_exons{$tr1}}, \@{${$transcript_exons{$tr2}}[$m]} );
	}
	for (my $m=$tr2IntronIndex+1; $m <= $#{$transcript_introns{$tr2}} ;$m++) {
		push (@{$transcript_introns{$tr1}}, \@{${$transcript_introns{$tr2}}[$m]} );
	}

}

